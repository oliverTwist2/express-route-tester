import fs from "fs/promises";
import path from "path";
import yaml from "yaml";

export async function exportToFile(results, conflicts, outputFile) {
  const ext = path.extname(outputFile).toLowerCase();

  let content;
  if (ext === ".json") {
    content = JSON.stringify(
      {
        globalMiddleware: results.globalMiddleware,
        routes: results.routes,
        warnings: results.warnings,
        conflicts,
        coverage: results.coverage,
      },
      null,
      2
    );
  } else if (ext === ".md") {
    content = generateMarkdown(results, conflicts);
  } else {
    throw new Error("Unsupported file format. Use .json or .md");
  }

  await fs.writeFile(outputFile, content, "utf-8");
}

function generateMarkdown(results, conflicts) {
  let markdown = `# Express Route Tester Results\n\n`;

  markdown += `## ðŸŒ Global Middleware\n`;
  if (results.globalMiddleware.length === 0) {
    markdown += `No global middleware found.\n\n`;
  } else {
    results.globalMiddleware.forEach((middleware, i) => {
      markdown += `${i + 1}. ${middleware}\n`;
    });
    markdown += `\n`;
  }

  markdown += `## ðŸ“¦ Routes\n`;
  if (results.routes.length === 0) {
    markdown += `No routes found.\n\n`;
  } else {
    results.routes.forEach((route) => {
      const methods = route.methods.join(", ");
      const handlers = route.handlers.join(" â†’ ");
      markdown += `- **${methods}** ${route.path} â†’ ${handlers}\n`;
    });
    markdown += `\n`;
  }

  markdown += `## âš ï¸ Conflicts\n`;
  if (conflicts.length === 0) {
    markdown += `No conflicts detected.\n\n`;
  } else {
    conflicts.forEach((conflict) => {
      markdown += `- ${conflict}\n`;
    });
    markdown += `\n`;
  }

  if (results.coverage) {
    markdown += `## ðŸŸ  Unused Global Middleware\n`;
    if (results.coverage.unusedMiddleware.length === 0) {
      markdown += `All global middleware is used by at least one route.\n\n`;
    } else {
      results.coverage.unusedMiddleware.forEach((mw) => {
        markdown += `- ${mw}\n`;
      });
      markdown += `\n`;
    }

    markdown += `## ðŸŸ¡ Routes Without Middleware\n`;
    if (results.coverage.routesWithoutMiddleware.length === 0) {
      markdown += `All routes have middleware coverage.\n\n`;
    } else {
      results.coverage.routesWithoutMiddleware.forEach((route) => {
        markdown += `- ${route}\n`;
      });
      markdown += `\n`;
    }
  }

  return markdown;
}

// OpenAPI export function
export async function exportOpenAPI(results, outputFile) {
  const ext = path.extname(outputFile).toLowerCase();

  // Basic OpenAPI 3.0 structure
  const openapi = {
    openapi: "3.0.0",
    info: {
      title: "Express API",
      version: "1.0.0",
      description: "Auto-generated by Express Route Tester"
    },
    paths: {}
  };

  for (const route of results.routes) {
    if (!openapi.paths[route.path]) openapi.paths[route.path] = {};
    for (const method of route.methods) {
      openapi.paths[route.path][method.toLowerCase()] = {
        summary: route.handlers.join(" â†’ "),
        responses: {
          "200": { description: "Success" }
        }
      };
    }
  }

  let content;
  if (ext === ".json") {
    content = JSON.stringify(openapi, null, 2);
  } else if (ext === ".yaml" || ext === ".yml") {
    content = yaml.stringify(openapi);
  } else {
    throw new Error("Unsupported OpenAPI file format. Use .json or .yaml");
  }

  await fs.writeFile(outputFile, content, "utf-8");
}